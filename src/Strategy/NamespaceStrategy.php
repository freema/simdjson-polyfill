<?php

declare(strict_types=1);

namespace SimdJsonPolyfill\Strategy;

/**
 * Namespace strategy - generates namespace-specific json_decode functions.
 *
 * Creates json_decode() functions in specified namespaces that use simdjson.
 * Less risky than UOPZ but requires namespace configuration.
 */
final class NamespaceStrategy implements StrategyInterface
{
    private PolyfillStrategy $polyfill;
    /** @var array<string> */
    private array $namespaces = [];

    public function __construct()
    {
        $this->polyfill = new PolyfillStrategy();
    }

    public function isAvailable(): bool
    {
        return extension_loaded('simdjson');
    }

    public function enable(array $config = []): void
    {
        if (!$this->isAvailable()) {
            throw new \RuntimeException(
                'NamespaceStrategy requires ext-simdjson to be installed.'
            );
        }

        $this->namespaces = $config['namespaces'] ?? [];

        if (empty($this->namespaces)) {
            throw new \RuntimeException(
                'NamespaceStrategy requires "namespaces" configuration with at least one namespace.'
            );
        }

        $this->generateNamespaceFunctions($config['output_dir'] ?? null);
    }

    public function decode(
        string $json,
        ?bool $associative = null,
        int $depth = 512,
        int $flags = 0
    ): mixed {
        return $this->polyfill->decode($json, $associative, $depth, $flags);
    }

    public function getName(): string
    {
        return 'namespace';
    }

    public function getPriority(): int
    {
        return 0; // Requires explicit configuration, not auto-detected
    }

    /**
     * Generate namespace-specific json_decode functions.
     *
     * @param string|null $outputDir Directory to write generated files
     */
    private function generateNamespaceFunctions(?string $outputDir): void
    {
        $outputDir = $outputDir ?? sys_get_temp_dir() . '/simdjson-polyfill';

        if (!is_dir($outputDir) && !mkdir($outputDir, 0755, true)) {
            throw new \RuntimeException("Failed to create output directory: {$outputDir}");
        }

        foreach ($this->namespaces as $namespace) {
            $this->generateNamespaceFunction($namespace, $outputDir);
        }
    }

    /**
     * Generate a single namespace function file.
     *
     * @param string $namespace
     * @param string $outputDir
     */
    private function generateNamespaceFunction(string $namespace, string $outputDir): void
    {
        $namespace = trim($namespace, '\\');
        $safeFilename = str_replace('\\', '_', $namespace);
        $filePath = $outputDir . '/' . $safeFilename . '_json_decode.php';

        $code = $this->generateFunctionCode($namespace);

        if (file_put_contents($filePath, $code) === false) {
            throw new \RuntimeException("Failed to write namespace function to: {$filePath}");
        }

        // Auto-load the generated function
        require_once $filePath;
    }

    /**
     * Generate the PHP code for a namespace-specific json_decode function.
     *
     * @param string $namespace
     * @return string
     */
    private function generateFunctionCode(string $namespace): string
    {
        return <<<PHP
<?php

declare(strict_types=1);

namespace {$namespace};

/**
 * Namespace-specific json_decode that uses simdjson when available.
 * Auto-generated by SimdJsonPolyfill\\Strategy\\NamespaceStrategy
 */
function json_decode(
    string \$json,
    ?bool \$associative = null,
    int \$depth = 512,
    int \$flags = 0
): mixed {
    static \$polyfill = null;

    if (\$polyfill === null) {
        \$polyfill = new \\SimdJsonPolyfill\\Strategy\\PolyfillStrategy();
    }

    return \$polyfill->decode(\$json, \$associative, \$depth, \$flags);
}

PHP;
    }
}
